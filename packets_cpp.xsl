<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet
    version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:output method="text" encoding="Windows-1252"/>
    <xsl:variable name="empty" select="/@empty" />
    <xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'" />
    <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'" />
    <xsl:template name="ParseType">
        <xsl:param name="type"/>
        <xsl:choose>
            <xsl:when test="$type='Boolean'"></xsl:when>
            <xsl:when test="$type='Byte'"></xsl:when>
            <xsl:when test="$type='UnsignedByte'"></xsl:when>
            <xsl:when test="$type='Short'"></xsl:when>
            <xsl:when test="$type='UnsignedShort'"></xsl:when>
            <xsl:when test="$type='Int'"></xsl:when>
            <xsl:when test="$type='Long'"></xsl:when>
            <xsl:when test="$type='Float'"></xsl:when>
            <xsl:when test="$type='Double'"></xsl:when>
            <xsl:when test="$type='String'"></xsl:when>
            <xsl:when test="$type='Chat'"></xsl:when>
            <xsl:when test="$type='VarInt'"></xsl:when>
            <xsl:when test="$type='VarLong'"></xsl:when>
            <xsl:when test="$type='Chunk'"></xsl:when>
            <xsl:when test="$type='Metadata'"></xsl:when>
            <xsl:when test="$type='Slot'"></xsl:when>
            <xsl:when test="$type='ObjectData'"></xsl:when>
            <xsl:when test="$type='NBTTag'"></xsl:when>
            <xsl:when test="$type='Position'"></xsl:when>
            <xsl:when test="$type='Angle'"></xsl:when>
            <xsl:when test="$type='UUID'"></xsl:when>
            <xsl:when test="$type='Array'"></xsl:when>
        </xsl:choose>
    </xsl:template>

  <xsl:template match="/">/* autogenerated file */
#include "stdafx.h"
#include "packets.h"
#include "MinecraftProtoParser.h"

void getAllPackets(std::vector&lt;APacket *> &amp;packets)
{
    <xsl:for-each select="/proto/packet">
    packets.push_back(new <xsl:value-of select="./@state"/>_<xsl:value-of select="./@name"/>_<xsl:value-of select="./@boundto"/>());</xsl:for-each>    
}

<xsl:for-each select="/proto/class">
/////////////////////////////////////////////////////////////////////////
// <xsl:value-of select="./@name"/>
/////////////////////////////////////////////////////////////////////////
bool <xsl:value-of select="./@name"/>::internal_parse(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, guint32 &amp;offset)
{
    proto_item *mc_item = proto_tree_add_item(tree, MinecraftProtoParser::getInstance()->getProto(), tvb, offset, length, FALSE);
    tree = proto_item_add_subtree(mc_item, mc_item);
}

guint <xsl:value-of select="./@name"/>::dataLength()
{
    return -1;
}
</xsl:for-each>

<xsl:for-each select="/proto/packet"><xsl:variable name="classname" select="./@name" />
/////////////////////////////////////////////////////////////////////////
// <xsl:value-of select="./@state"/>_<xsl:value-of select="./@name"/>_<xsl:value-of select="./@boundto"/>
/////////////////////////////////////////////////////////////////////////

<xsl:value-of select="./@state"/>_<xsl:value-of select="./@name"/>_<xsl:value-of select="./@boundto"/>::<xsl:value-of select="./@state"/>_<xsl:value-of select="./@name"/>_<xsl:value-of select="./@boundto"/>()
    : APacket()
    <xsl:for-each select="./field">
    , hf_mc_id_<xsl:value-of select="./@name"/>(-1)</xsl:for-each>
{
    <xsl:for-each select="./field">
        <xsl:choose>
            <xsl:when test="./@type='Boolean'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_BOOLEAN, BASE_DEC, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='Byte'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_INT8, BASE_DEC, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='UnsignedByte'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_INT8, BASE_DEC, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='Short'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_INT8, BASE_DEC, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='UnsignedShort'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_INT8, BASE_DEC, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='Int'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_INT32, BASE_DEC, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='Long'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_INT64, BASE_DEC, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='Float'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_FLOAT, BASE_NONE, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='Double'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_DOUBLE, BASE_NONE, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='String'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_STRING, BASE_NONE, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='Chat'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_STRING, BASE_NONE, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='VarInt'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_INT32, BASE_DEC, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='VarLong'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_INT64, BASE_DEC, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='Chunk'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_STRING, BASE_NONE, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='Metadata'"></xsl:when>
            <xsl:when test="./@type='Slot'"></xsl:when>
            <xsl:when test="./@type='ObjectData'"></xsl:when>
            <xsl:when test="./@type='NBTTag'"></xsl:when>
            <xsl:when test="./@type='Position'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_UINT64, BASE_DEC, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='Angle'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_UINT8, BASE_DEC, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='UUID'">
                hf_mc_<xsl:value-of select="./@name"/> = {&amp;hf_mc_id_<xsl:value-of select="./@name"/>, {
    "<xsl:value-of select="./@name"/>", "mc.<xsl:value-of select="translate($classname, $uppercase, $smallcase)"/>_<xsl:value-of select="translate(./@name, $uppercase, $smallcase)"/>", FT_GUID, BASE_NONE, NULL, 0x0, "<xsl:value-of select="./@name"/>", HFILL}};
    mRegInfo.push_back(&amp;hf_mc_<xsl:value-of select="./@name"/>);</xsl:when>
            <xsl:when test="./@type='Array'"></xsl:when>
        </xsl:choose>
    </xsl:for-each>
}

<xsl:value-of select="./@state"/>_<xsl:value-of select="./@name"/>_<xsl:value-of select="./@boundto"/>::~<xsl:value-of select="./@state"/>_<xsl:value-of select="./@name"/>_<xsl:value-of select="./@boundto"/>()
{
}

bool <xsl:value-of select="./@state"/>_<xsl:value-of select="./@name"/>_<xsl:value-of select="./@boundto"/>::isClientSide()
{
    <xsl:choose>
    <xsl:when test="./@boundto='Client'">return true;</xsl:when>
    <xsl:when test="./@boundto='Server'">return false;</xsl:when>
    <xsl:otherwise>
        #pragma message("WHAAAAT? what is type '<xsl:value-of select="./@boundto"/>'")
        return false;
    </xsl:otherwise>
    </xsl:choose>
}

APacket::EState <xsl:value-of select="./@state"/>_<xsl:value-of select="./@name"/>_<xsl:value-of select="./@boundto"/>::getState()
{
    return APacket::eState<xsl:value-of select="./@state"/>;
}

hf_register_info *<xsl:value-of select="./@state"/>_<xsl:value-of select="./@name"/>_<xsl:value-of select="./@boundto"/>::getFieldInfo_internal()
{
    return mRegInfo[0];
}

int <xsl:value-of select="./@state"/>_<xsl:value-of select="./@name"/>_<xsl:value-of select="./@boundto"/>::getId()
{
    return <xsl:value-of select="./@id"/>;
}

bool <xsl:value-of select="./@state"/>_<xsl:value-of select="./@name"/>_<xsl:value-of select="./@boundto"/>::internal_parse(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, guint32 &amp;offset)
{
    return true;    
}

const char *<xsl:value-of select="./@state"/>_<xsl:value-of select="./@name"/>_<xsl:value-of select="./@boundto"/>::getName()
{
    return "<xsl:value-of select="./@name"/>";
}

</xsl:for-each>
  </xsl:template>
</xsl:stylesheet>